/**
 * Server Tool: Generate Summary
 * Generates a summary of the conversation for the patient to download
 */

interface ConversationMessage {
  role: 'user' | 'agent';
  content: string;
  timestamp?: string;
}

interface GenerateSummaryRequest {
  conversation_id: string;
  report_id: string;
  format?: 'text' | 'pdf' | 'json';
  transcript?: ConversationMessage[];
}

interface GenerateSummaryResponse {
  success: boolean;
  summary_id?: string;
  content?: string;
  format?: string;
  created_at?: string;
  download_url?: string;
  error?: string;
}

/**
 * Generate a summary of the conversation
 * This tool is called by the ElevenLabs agent to create a downloadable summary
 */
export async function generateSummary(
  request: GenerateSummaryRequest
): Promise<GenerateSummaryResponse> {
  try {
    const { conversation_id, report_id, format = 'text', transcript = [] } = request;

    if (!conversation_id || !report_id) {
      return {
        success: false,
        error: 'conversation_id and report_id are required',
      };
    }

    // Call backend API to generate summary
    const response = await fetch('/api/summaries', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        report_id,
        transcript,
        language: 'en',
      }),
    });

    if (!response.ok) {
      return {
        success: false,
        error: `Failed to generate summary: ${response.statusText}`,
      };
    }

    const data = await response.json();

    if (!data.success) {
      return {
        success: false,
        error: data.error || 'Unknown error occurred',
      };
    }

    const summary = data.summary;
    const summaryContent = formatSummary(summary, format);

    return {
      success: true,
      summary_id: summary.report_id,
      content: summaryContent,
      format,
      created_at: summary.generated_at,
      download_url: `/api/summaries?report_id=${report_id}`,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Format summary based on requested format
 */
function formatSummary(
  summary: any,
  format: 'text' | 'pdf' | 'json'
): string {
  if (format === 'json') {
    return JSON.stringify(summary, null, 2);
  }

  if (format === 'pdf') {
    // For PDF, return text that can be converted to PDF
    return formatAsText(summary);
  }

  return formatAsText(summary);
}

/**
 * Format summary as plain text
 */
function formatAsText(summary: any): string {
  const lines = [
    'TELEHEALTH INSIGHT COMPANION - SESSION SUMMARY',
    '='.repeat(50),
    '',
    `Generated: ${new Date(summary.generated_at).toLocaleString()}`,
    `Report ID: ${summary.report_id}`,
    '',
  ];

  if (summary.findings && summary.findings.length > 0) {
    lines.push('KEY FINDINGS:');
    summary.findings.forEach((finding: string, index: number) => {
      lines.push(`${index + 1}. ${finding}`);
    });
    lines.push('');
  }

  if (summary.recommendations && summary.recommendations.length > 0) {
    lines.push('RECOMMENDATIONS:');
    summary.recommendations.forEach((rec: string, index: number) => {
      lines.push(`${index + 1}. ${rec}`);
    });
    lines.push('');
  }

  if (summary.follow_up_actions && summary.follow_up_actions.length > 0) {
    lines.push('FOLLOW-UP ACTIONS:');
    summary.follow_up_actions.forEach((action: string, index: number) => {
      lines.push(`${index + 1}. ${action}`);
    });
    lines.push('');
  }

  if (
    summary.key_questions_answered &&
    summary.key_questions_answered.length > 0
  ) {
    lines.push('QUESTIONS DISCUSSED:');
    summary.key_questions_answered.forEach((q: string, index: number) => {
      lines.push(`${index + 1}. ${q}`);
    });
    lines.push('');
  }

  lines.push('='.repeat(50));
  lines.push(
    'This summary was generated by the Telehealth Insight Companion.'
  );
  lines.push('Please consult with your healthcare provider for medical advice.');

  return lines.join('\n');
}

/**
 * Extract key points from transcript
 */
export function extractKeyPoints(transcript: ConversationMessage[]): {
  findings: string[];
  questions: string[];
} {
  const findings: string[] = [];
  const questions: string[] = [];

  transcript.forEach((msg) => {
    if (msg.role === 'user') {
      const content = msg.content.toLowerCase();
      if (
        content.includes('?') ||
        content.includes('what') ||
        content.includes('why')
      ) {
        questions.push(msg.content);
      }
    } else if (msg.role === 'agent') {
      if (msg.content.length > 50) {
        const sentences = msg.content
          .split(/[.!?]+/)
          .filter((s) => s.trim().length > 0);
        findings.push(...sentences.slice(0, 2).map((s) => s.trim()));
      }
    }
  });

  return { findings, questions };
}
